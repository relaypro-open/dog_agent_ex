# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-12-26 15:52:15


defmodule :dog_file_transfer do

  @defined_FILE_HRL_ System.get_env("DEFINE_FILE_HRL_") != nil

  require Logger
  require Record

  @behaviour :gen_server


  # Begin included file: include/file.hrl from library kernel


  if not @defined_FILE_HRL_ do


  defmacrop erlconst_FILE_HRL_() do
    quote do
      1
    end
  end
  @defined_FILE_HRL_ true


  @erlrecordfields_file_info [:size, :type, :access, :atime, :mtime, :ctime, :mode, :links, :major_device, :minor_device, :inode, :uid, :gid]
  Record.defrecordp :erlrecord_file_info, :file_info, [size: :undefined, type: :undefined, access: :undefined, atime: :undefined, mtime: :undefined, ctime: :undefined, mode: :undefined, links: :undefined, major_device: :undefined, minor_device: :undefined, inode: :undefined, uid: :undefined, gid: :undefined]

  @erlrecordfields_file_descriptor [:module, :data]
  Record.defrecordp :erlrecord_file_descriptor, :file_descriptor, [module: :undefined, data: :undefined]


  end


  # End included file: include/file.hrl from library kernel


  defmacrop erlconst_SANDBOX_FILE_ROOT() do
    quote do
      '/'
    end
  end


  def subscriber_loop(_routingKey, _cType, payload, state) do
    message = :erlang.binary_to_term(payload)
    apiUser = :proplists.get_value(:api_user, message, 'undefined')
    case(apiUser) do
      'undefined' ->
        {:ack, {:error, "no api_user specified"}}
      _ ->
        filename = :dog_common.to_list(:proplists.get_value(:file_name, message))
        command = :proplists.get_value(:command, message)
        userData = :proplists.get_value(:user_data, message)
        case(command) do
          :send_file ->
            try do
              filenameClean = :filelib.safe_relative_path(:string.trim(filename, :leading, '/'), [])
              filePath = erlconst_SANDBOX_FILE_ROOT() ++ filenameClean
              case(filenameClean) do
                :unsafe ->
                  {:reply, "text/json", :jsx.encode(:file_bad), state}
                _ ->
                  fileTotalBlocks = :proplists.get_value(:total_blocks, message)
                  fileCurrentBlock = :proplists.get_value(:current_block, message)
                  maxBlockSizeBytes = :proplists.get_value(:max_block_size_bytes, message)
                  fileBlock = :maps.get(:file_block, userData)
                  {:ok, ioDevice} = case(fileCurrentBlock) do
                    1 ->
                      :filelib.ensure_dir(:filename.dirname(filePath) ++ '/')
                      :file.open(filePath, [:write, :raw])
                    _ ->
                      :file.open(filePath, [:write, :read, :raw])
                  end
                  case(fileCurrentBlock) do
                    1 when fileTotalBlocks === 1 ->
                      :file.pwrite(ioDevice, 0, fileBlock)
                      :file.close(ioDevice)
                      {:ack, state}
                    1 when fileTotalBlocks > 1 ->
                      :file.pwrite(ioDevice, 0, fileBlock)
                      {:ack, state}
                    n when n >= fileTotalBlocks ->
                      startByte = (fileCurrentBlock - 1) * maxBlockSizeBytes
                      :file.pwrite(ioDevice, startByte, fileBlock)
                      :file.close(ioDevice)
                      {:ack, state}
                    _ ->
                      startByte = (fileCurrentBlock - 1) * maxBlockSizeBytes
                      :file.pwrite(ioDevice, startByte, fileBlock)
                      {:ack, state}
                  end
              end
            catch
              exception, reason ->
                Logger.debug('#{exception}, #{reason}')
                {:ack, reason}
            else
              {:ack, newState} ->
                {:ack, newState}
            end
          :delete_file ->
            try do
              filenameClean = :filelib.safe_relative_path(:string.trim(filename, :leading, '/'), [])
              filePath = erlconst_SANDBOX_FILE_ROOT() ++ filenameClean
              case(filenameClean) do
                :unsafe ->
                  {:reply, "text/json", :jsx.encode(:file_bad), state}
                _ ->
                  case(:filelib.is_dir(filePath)) do
                    true ->
                      case(:file.del_dir(filePath)) do
                        {:error, error} ->
                          {:reply, "text/json", :jsx.encode(error: error)}
                        :ok ->
                          {:reply, "text/json", :jsx.encode([:ok]), state}
                      end
                    false ->
                      case(:file.delete(filePath)) do
                        {:error, error} ->
                          {:reply, "text/json", :jsx.encode(error: error)}
                        :ok ->
                          {:reply, "text/json", :jsx.encode([:ok]), state}
                      end
                  end
              end
            catch
              exception, reason ->
                Logger.debug('#{exception}, #{reason}')
                {:reply, "text/json", :jsx.encode([reason]), state}
            else
              reply ->
                reply
            end
          :fetch_file ->
            try do
              case(:file.read_file(filename)) do
                {:ok, bytes} ->
                  {:reply, "application/octet-stream", bytes, state}
                {:error, error} ->
                  {:reply, "text/json", :jsx.encode(error: error), state}
              end
            catch
              exception, reason ->
                Logger.debug('#{exception}, #{reason}')
                {:reply, "text/json", :jsx.encode([reason]), state}
            else
              reply ->
                reply
            end
          :execute_command ->
            try do
              executeCommandBase64 = :proplists.get_value(:execute_command, message)
              executeCommandRaw = :base64.decode(executeCommandBase64)
              useShell = :proplists.get_value(:use_shell, message, false)
              runAsUser = :proplists.get_value(:user, message, 'dog')
              executeCommand = case(useShell) do
                true ->
                  executeCommandRaw
                false ->
                  :string.split(executeCommandRaw, ' ')
              end
              result = :exec.run(executeCommand, [:sync, :stdout, :stderr, {:user, runAsUser}])
              case(result) do
                {:ok, [stdout: stdOut]} ->
                  case(length(stdOut) > 1) do
                    true ->
                      parsedStdOut = [:dog_common.binary_join(tl(stdOut), "")]
                      {:reply, "text/json", :jsx.encode(ok: parsedStdOut), state}
                    false ->
                      {:reply, "text/json", :jsx.encode(ok: stdOut), state}
                  end
                {:ok, []} ->
                  {:reply, "text/json", :jsx.encode(ok: []), state}
                {:error, [exit_status: _exitStatus, stdout: stdOut]} ->
                  {:reply, "text/json", :jsx.encode(error: stdOut), state}
                {:error, [exit_status: _exitStatus, stderr: stdErr]} ->
                  {:reply, "text/json", :jsx.encode(error: stdErr), state}
                unknownResponse ->
                  {:reply, "text/json", {:error, [unknownResponse]}, state}
              end
            catch
              exception, reason ->
                Logger.debug('#{exception}, #{reason}')
                {:reply, "text/json", :jsx.encode(error: reason), state}
            else
              reply ->
                reply
            end
          _ ->
            {:reply, "text/json", :jsx.encode(:error), state}
        end
    end
  end


  @spec start_link(map()) :: {:ok, pid()} | :ignore | {:error, {:already_started, pid()} | term()}


  def start_link(link) do
    :gen_server.start_link({:local, __MODULE__}, __MODULE__, [link], [])
  end


  def init([]) do
    state = []
    {:ok, state}
  end


  @spec handle_call(term(), {pid(), term()}, map()) :: {:reply, :ok, any()}


  def handle_call(_request, _from, state) do
    {:reply, :ok, state}
  end


  @spec handle_cast(_, _) :: {:noreply, _} when _: any()


  def handle_cast(:stop, state) do
    {:stop, :normal, state}
  end

  def handle_cast(msg, state) do
    {:noreply, state}
  end


  @spec handle_info(_, _) :: {:noreply, _} when _: any()


  def handle_info(info, state) do
    {:noreply, state}
  end


  @spec terminate(_, map()) :: {:close} when _: any()


  def terminate(reason, state) do
    {:close}
  end


  @spec code_change(_, map(), _) :: {:ok, map()} when _: any()


  def code_change(_oldVsn, state, _extra) do
    {:ok, state}
  end

end
