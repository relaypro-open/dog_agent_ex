# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-12-26 15:52:15


defmodule :dog_file_transfer do

  @defined_FILE_HRL_ System.get_env("DEFINE_FILE_HRL_") != nil

  require Logger
  require Record
  require DogMacros
  alias DogMacros, as: M

  @behaviour :gen_server


  # Begin included file: include/file.hrl from library kernel


  if not @defined_FILE_HRL_ do


  defmacrop erlconst_FILE_HRL_() do
    quote do
      1
    end
  end
  @defined_FILE_HRL_ true


  @erlrecordfields_file_info [:size, :type, :access, :atime, :mtime, :ctime, :mode, :links, :major_device, :minor_device, :inode, :uid, :gid]
  Record.defrecordp :erlrecord_file_info, :file_info, [size: :undefined, type: :undefined, access: :undefined, atime: :undefined, mtime: :undefined, ctime: :undefined, mode: :undefined, links: :undefined, major_device: :undefined, minor_device: :undefined, inode: :undefined, uid: :undefined, gid: :undefined]

  @erlrecordfields_file_descriptor [:module, :data]
  Record.defrecordp :erlrecord_file_descriptor, :file_descriptor, [module: :undefined, data: :undefined]


  end


  # End included file: include/file.hrl from library kernel



  def subscriber_loop(_routingKey, _cType, payload, state) do
    message = :erlang.binary_to_term(payload)
    apiUser = :proplists.get_value(:api_user, message, 'undefined')
    case(apiUser) do
      'undefined' ->
        {:ack, {:error, "no api_user specified"}}
      _ ->
        filename = :dog_common.to_list(:proplists.get_value(:file_name, message))
        command = :proplists.get_value(:command, message)
        userData = :proplists.get_value(:user_data, message)
        case(command) do
          :send_file ->
            send_file(state, apiUser, message, filename, userData)
          :delete_file ->
            delete_file(state, apiUser, filename)
          :fetch_file ->
            fetch_file(state, apiUser, filename)
          :execute_command ->
            execute_command(state, apiUser, message)
          _ ->
            {:reply, "text/json", :jsx.encode(:error), state}
        end
    end
  end

  def send_file(state, apiUser, message, filename, userData) do
    try do
      filenameClean = :filelib.safe_relative_path(:string.trim(filename, :leading, '/'), [])
      filePath = M.erlconst_SANDBOX_FILE_ROOT() ++ filenameClean
      case(filenameClean) do
        :unsafe ->
          {:reply, "text/json", :jsx.encode(:file_bad), state}
        _ ->
          fileTotalBlocks = :proplists.get_value(:total_blocks, message)
          fileCurrentBlock = :proplists.get_value(:current_block, message)
          maxBlockSizeBytes = :proplists.get_value(:max_block_size_bytes, message)
          fileBlock = :maps.get(:file_block, userData)
          {:ok, ioDevice} = case(fileCurrentBlock) do
            1 ->
              :filelib.ensure_dir(:filename.dirname(filePath) ++ '/')
              :file.open(filePath, [:write, :raw])
            _ ->
              :file.open(filePath, [:write, :read, :raw])
          end
          case(fileCurrentBlock) do
            1 when fileTotalBlocks === 1 ->
              :file.pwrite(ioDevice, 0, fileBlock)
              :file.close(ioDevice)
              {:ack, state}
            1 when fileTotalBlocks > 1 ->
              :file.pwrite(ioDevice, 0, fileBlock)
              {:ack, state}
            n when n >= fileTotalBlocks ->
              startByte = (fileCurrentBlock - 1) * maxBlockSizeBytes
              :file.pwrite(ioDevice, startByte, fileBlock)
              :file.close(ioDevice)
              {:ack, state}
            _ ->
              startByte = (fileCurrentBlock - 1) * maxBlockSizeBytes
              :file.pwrite(ioDevice, startByte, fileBlock)
              {:ack, state}
          end
      end
    after
      {:ack, :crash}
    end
  end

  def delete_file(state, apiUser, filename) do
    try do
      filenameClean = :filelib.safe_relative_path(:string.trim(filename, :leading, '/'), [])
      filePath = M.erlconst_SANDBOX_FILE_ROOT() ++ filenameClean
      case(filenameClean) do
        :unsafe ->
          {:reply, "text/json", :jsx.encode(:file_bad), state}
        _ ->
          case(:filelib.is_dir(filePath)) do
            true ->
              case(:file.del_dir(filePath)) do
                {:error, error} ->
                  {:reply, "text/json", :jsx.encode(error: error)}
                :ok ->
                  {:reply, "text/json", :jsx.encode([:ok]), state}
              end
            false ->
              case(:file.delete(filePath)) do
                {:error, error} ->
                  {:reply, "text/json", :jsx.encode(error: error)}
                :ok ->
                  {:reply, "text/json", :jsx.encode([:ok]), state}
              end
          end
      end
    catch #TODO: replace with 'after'
      exception, reason ->
        Logger.debug("#{exception}, #{reason}")
        {:reply, "text/json", :jsx.encode([reason]), state}
    else
      reply ->
        reply
    end
  end

  def fetch_file(state, apiUser, filename) do
    try do
      case(:file.read_file(filename)) do
        {:ok, bytes} ->
          {:reply, "application/octet-stream", bytes, state}
        {:error, error} ->
          {:reply, "text/json", :jsx.encode(error: error), state}
      end
    catch #TODO: replace with 'after'
      exception, reason ->
        Logger.debug("#{exception}, #{reason}")
        {:reply, "text/json", :jsx.encode([reason]), state}
    else
      reply ->
        reply
    end
  end

  def execute_command(state, apiUser, message) do
    try do
      executeCommandBase64 = :proplists.get_value(:execute_command, message)
      executeCommandRaw = :base64.decode(executeCommandBase64)
      useShell = :proplists.get_value(:use_shell, message, false)
      cmd_user = Application.get_env(:dog, :cmd_user, 'dog')
      runAsUser = :proplists.get_value(:user, message, cmd_user)
      executeCommand = case(useShell) do
        true ->
          executeCommandRaw
        false ->
          :string.split(executeCommandRaw, ' ')
      end
      result = :exec.run(executeCommand, [:sync, :stdout, :stderr, {:user, runAsUser}])
      Logger.debug("result: #{inspect(result)}")
      case(result) do
        {:ok, [stdout: stdOut]} ->
          case(length(stdOut) > 1) do
            true ->
              parsedStdOut = Enum.join(stdOut, "")
              {:reply, "text/json", :jsx.encode(ok: parsedStdOut), state}
            false ->
              {:reply, "text/json", :jsx.encode(ok: stdOut), state}
          end
        {:ok, []} ->
          {:reply, "text/json", :jsx.encode(ok: []), state}
        {:error, [exit_status: _exitStatus, stdout: stdOut]} ->
          {:reply, "text/json", :jsx.encode(error: stdOut), state}
        {:error, [exit_status: _exitStatus, stderr: stdErr]} ->
          {:reply, "text/json", :jsx.encode(error: stdErr), state}
        {:error, reason} ->
          {:reply, "text/json", :jsx.encode(error: List.to_string(reason)), state}
        unknownResponse ->
          {:reply, "text/json", {:error, [unknownResponse]}, state}
      end
    after 
        :crash
    end
  end
 
  @spec start_link(map()) :: {:ok, pid()} | :ignore | {:error, {:already_started, pid()} | term()}


  def start_link(link) do
    :gen_server.start_link({:local, __MODULE__}, __MODULE__, [link], [])
  end


  def init([]) do
    state = []
    {:ok, state}
  end


  @spec handle_call(term(), {pid(), term()}, map()) :: {:reply, :ok, any()}


  def handle_call(_request, _from, state) do
    {:reply, :ok, state}
  end


  @spec handle_cast(_, _) :: {:noreply, _} when _: any()


  def handle_cast(:stop, state) do
    {:stop, :normal, state}
  end

  def handle_cast(msg, state) do
    {:noreply, state}
  end


  @spec handle_info(_, _) :: {:noreply, _} when _: any()


  def handle_info(info, state) do
    {:noreply, state}
  end


  @spec terminate(_, map()) :: {:close} when _: any()


  def terminate(reason, state) do
    {:close}
  end


  @spec code_change(_, map(), _) :: {:ok, map()} when _: any()


  def code_change(_oldVsn, state, _extra) do
    {:ok, state}
  end

end
