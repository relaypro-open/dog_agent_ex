# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-12-26 15:52:17


defmodule :dog_iptables do
  require Logger
  require DogMacros
  alias DogMacros, as: M


  defp write_ipv4_docker_nat_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/iptables-docker-nat.txt'
    :ok = File.write(tempfile, ruleset)
    {:ok, tempfile}
  end


  defp write_ipv4_docker_filter_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/iptables-docker-filter.txt'
    :ok = File.write(tempfile, ruleset)
    {:ok, tempfile}
  end


  @spec write_ipv4_ruleset(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: {:ok, charlist()}


  def write_ipv4_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/iptables.txt'
    :ok = File.write(tempfile, ruleset)
    {:ok, tempfile}
  end


  @spec write_ipv6_ruleset(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: {:ok, charlist()}


  def write_ipv6_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/ip6tables.txt'
    :ok = File.write(tempfile, ruleset)
    {:ok, tempfile}
  end


  @spec write_ipv4_iptables_ruleset(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: :ok


  defp write_ipv4_iptables_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/ip4tables_iptables.txt'
    :ok = File.write(tempfile, ruleset)
    :ok
  end


  @spec write_ipv6_iptables_ruleset(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: :ok


  defp write_ipv6_iptables_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/ip6tables_iptables.txt'
    :ok = File.write(tempfile, ruleset)
    :ok
  end


  @spec write_ipv4_ipsets_ruleset(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: :ok


  defp write_ipv4_ipsets_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/ip4tables_ipsets.txt'
    :ok = File.write(tempfile, ruleset)
    :ok
  end


  @spec write_ipv6_ipsets_ruleset(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: :ok


  defp write_ipv6_ipsets_ruleset(ruleset) do
    tempfile = M.erlconst_RUNDIR() ++ '/ip6tables_ipsets.txt'
    :ok = File.write(tempfile, ruleset)
    :ok
  end


  @spec persist_ipv4_tables() :: :error | :ok


  def persist_ipv4_tables() do
    enforcing = Application.get_env(:dog, :enforcing, true)
    cmd = case(enforcing) do
      false ->
        M.erlconst_IP4TABLES_SAVE_COMMAND() ++ ' > ' ++ M.erlconst_RUNDIR() ++ '/rules.v4'
      true ->
        M.erlconst_IP4TABLES_SAVE_COMMAND() ++ ' > /etc/iptables/rules.v4'
    end
    result = :dog_os.cmd(cmd)
    case(result) do
      [] ->
        :ok
      _ ->
        :error
    end
  end


  @spec rm_nat() :: charlist()


  defp rm_nat() do
    '*nat\nCOMMIT\n'
  end


  @spec apply_ipv4_ruleset(charlist()) :: :error | :ok


  defp apply_ipv4_ruleset(trainerFilterFile) do
    enforcing = Application.get_env(:dog, :enforcing, true)
    case(enforcing) do
      false ->
        :ok
      true ->
        case(:dog_docker.is_docker_instance()) do
          true ->
            {dockerNatRuleset, dockerFilterRuleset} = :dog_docker.iptables()
            write_ipv4_docker_nat_ruleset(dockerNatRuleset)
            write_ipv4_docker_filter_ruleset(dockerFilterRuleset)
            {:ok, trainerFilter} = File.read(trainerFilterFile)
            trainerFilterWithoutCommit = Enum.join(:lists.subtract(String.split(trainerFilter, '\n'), ['COMMIT']), '\n')
            dockerTrainerFilterFile = M.erlconst_RUNDIR() ++ '/iptables-docker-trainer-filter.txt'
            File.write(dockerTrainerFilterFile, trainerFilterWithoutCommit)
            dockerNatFile = M.erlconst_RUNDIR() ++ '/iptables-docker-nat.txt'
            dockerFilterFile = M.erlconst_RUNDIR() ++ '/iptables-docker-filter.txt'
            dockerIptablesFile = M.erlconst_RUNDIR() ++ '/iptables-docker.txt'
            concatCmd = 'cat ' ++ dockerTrainerFilterFile ++ ' ' ++ dockerFilterFile ++ ' ' ++ dockerNatFile ++ ' > ' ++ dockerIptablesFile
            :dog_os.cmd(concatCmd)
            cmd = M.erlconst_IP4TABLES_RESTORE_COMMAND() ++ ' ' ++ dockerIptablesFile
            result = :dog_os.cmd(cmd)
            case(result) do
              [] ->
                :ok
              _ ->
                :error
            end
          false ->
            removeNatFile = '/etc/dog_ex/rm-nat.txt'
            File.write(removeNatFile, rm_nat())
            cmd = 'cat ' ++ trainerFilterFile ++ ' ' ++ removeNatFile ++ ' | ' ++ M.erlconst_IP4TABLES_RESTORE_COMMAND()
            result = :dog_os.cmd(cmd)
            case(result) do
              [] ->
                :ok
              _ ->
                :error
            end
        end
    end
  end


  @spec persist_ipv6_tables() :: :error | :ok


  defp persist_ipv6_tables() do
    enforcing = Application.get_env(:dog, :enforcing, true)
    cmd = case(enforcing) do
      false ->
        M.erlconst_IP6TABLES_SAVE_COMMAND() ++ ' > ' ++ M.erlconst_RUNDIR() ++ '/rules.v6'
      true ->
        M.erlconst_IP6TABLES_SAVE_COMMAND() ++ ' > /etc/iptables/rules.v6'
    end
    result = :dog_os.cmd(cmd)
    case(result) do
      [] ->
        :ok
      _ ->
        :error
    end
  end


  @spec apply_ipv6_ruleset(charlist()) :: :error | :ok


  defp apply_ipv6_ruleset(tempFile) do
    enforcing = Application.get_env(:dog, :enforcing, true)
    case(enforcing) do
      false ->
        :ok
      true ->
        cmd = M.erlconst_IP6TABLES_RESTORE_COMMAND() ++ ' ' ++ tempFile
        result = :dog_os.cmd(cmd)
        case(result) do
          [] ->
            Logger.debug('applied ipv6 ruleset')
            :ok
          _ ->
            Logger.debug('validate_ipv6_ruleset Result: #{result}')
            :error
        end
    end
  end


  @spec read_current_ipv4_iptables() :: charlist()


  def read_current_ipv4_iptables() do
    useIpsets = Application.get_env(:dog, :use_ipsets, true)
    enforcing = Application.get_env(:dog, :enforcing, true)
    cmd = case(enforcing) do
      false ->
        'cat ' ++ M.erlconst_RUNDIR() ++ '/ip4tables_iptables.txt'
      true ->
        case(useIpsets) do
          false ->
            M.erlconst_IP4TABLES_SAVE_COMMAND()
          true ->
            'cat ' ++ M.erlconst_RUNDIR() ++ '/ip4tables_iptables.txt'
        end
    end
    result = :dog_os.cmd(cmd)
    :lists.flatten(result)
  end


  @spec read_current_ipv6_iptables() :: charlist()


  def read_current_ipv6_iptables() do
    useIpsets = Application.get_env(:dog, :use_ipsets, true)
    enforcing = Application.get_env(:dog, :enforcing, true)
    cmd = case(enforcing) do
      false ->
        'cat ' ++ M.erlconst_RUNDIR() ++ '/ip6tables_iptables.txt'
      true ->
        case(useIpsets) do
          false ->
            M.erlconst_IP6TABLES_SAVE_COMMAND()
          true ->
            'cat ' ++ M.erlconst_RUNDIR() ++ '/ip6tables_iptables.txt'
        end
    end
    result = :dog_os.cmd(cmd)
    result
  end


  @spec read_current_ipv4_ipsets() :: charlist()


  def read_current_ipv4_ipsets() do
    useIpsets = Application.get_env(:dog, :use_ipsets, true)
    enforcing = Application.get_env(:dog, :enforcing, true)
    cmd = case(enforcing) do
      false ->
        'cat ' ++ M.erlconst_RUNDIR() ++ '/ip4tables_ipsets.txt'
      true ->
        case(useIpsets) do
          false ->
            'cat ' ++ M.erlconst_RUNDIR() ++ '/ip4tables_ipsets.txt'
          true ->
            M.erlconst_IP4TABLES_SAVE_COMMAND()
        end
    end
    result = :dog_os.cmd(cmd)
    :lists.flatten(result)
  end


  @spec read_current_ipv6_ipsets() :: charlist()


  def read_current_ipv6_ipsets() do
    useIpsets = Application.get_env(:dog, :use_ipsets, true)
    enforcing = Application.get_env(:dog, :enforcing, true)
    cmd = case(enforcing) do
      false ->
        'cat ' ++ M.erlconst_RUNDIR() ++ '/ip6tables_ipsets.txt'
      true ->
        case(useIpsets) do
          false ->
            'cat ' ++ M.erlconst_RUNDIR() ++ '/ip6tables_ipsets.txt'
          true ->
            M.erlconst_IP6TABLES_SAVE_COMMAND()
        end
    end
    result = :dog_os.cmd(cmd)
    result
  end


  @spec backup_current_ipv4_iptables() :: :error | :ok


  defp backup_current_ipv4_iptables() do
    cmd = M.erlconst_IP4TABLES_SAVE_COMMAND() ++ ' > ' ++ M.erlconst_RUNDIR() ++ '/iptables.back'
    result = :dog_os.cmd(cmd)
    Logger.debug('backup_ipv4_iptables Result: #{result}')
    case(result) do
      [] ->
        :ok
      _ ->
        :error
    end
  end


  @spec backup_current_ipv6_iptables() :: :error | :ok


  defp backup_current_ipv6_iptables() do
    cmd = M.erlconst_IP6TABLES_SAVE_COMMAND() ++ ' > ' ++ M.erlconst_RUNDIR() ++ '/ip6tables.back'
    result = :dog_os.cmd(cmd)
    Logger.debug('backup_ipv6_iptables Result: #{result}')
    case(result) do
      [] ->
        :ok
      _ ->
        :error
    end
  end


  @spec update_iptables4(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: :ok


  defp update_iptables4(ruleset) do
    update_iptables4(ruleset, 0)
  end


  @spec update_iptables4(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | []), integer()) :: :ok


  defp update_iptables4(ruleset, retry) do
    iptablesRestoreRetryLimit = Application.get_env(:dog, :iptables_restore_retry_limit, 5)
    iptablesRestoreRetryWaitSeconds = Application.get_env(:dog, :iptables_restore_retry_wait_seconds, 3)
    :ok = backup_current_ipv4_iptables()
    {:ok, tempFile} = write_ipv4_ruleset(ruleset)
    case(apply_ipv4_ruleset(tempFile)) do
      :ok ->
        :ok = persist_ipv4_tables()
      :error ->
        case(retry) do
          r when r <= iptablesRestoreRetryLimit ->
            :timer.sleep(iptablesRestoreRetryWaitSeconds * 1000)
            Logger.debug('Retry count updating IPv4 iptables: #{r + 1}')
            update_iptables4(ruleset, r + 1)
          r when r > iptablesRestoreRetryLimit ->
            Logger.debug('Unable to restore iptables after retry number: #{r}')
        end
    end
  end


  @spec update_iptables6(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | [])) :: :ok


  defp update_iptables6(ruleset) do
    update_iptables6(ruleset, 0)
  end


  @spec update_iptables6(binary() | maybe_improper_list(binary() | maybe_improper_list(any(), binary() | []) | byte(), binary() | []), integer()) :: :ok


  defp update_iptables6(ruleset, retry) do
    iptablesRestoreRetryLimit = Application.get_env(:dog, :iptables_restore_retry_limit, 5)
    iptablesRestoreRetryWaitSeconds = Application.get_env(:dog, :iptables_restore_retry_wait_seconds, 3)
    :ok = backup_current_ipv6_iptables()
    {:ok, tempFile} = write_ipv6_ruleset(ruleset)
    case(apply_ipv6_ruleset(tempFile)) do
      :ok ->
        :ok = persist_ipv6_tables()
      :error ->
        case(retry) do
          r when r <= iptablesRestoreRetryLimit ->
            :timer.sleep(iptablesRestoreRetryWaitSeconds * 1000)
            Logger.debug('Retry count updating IPv6 iptables: #{r + 1}')
            update_iptables6(ruleset, r + 1)
          r when r > iptablesRestoreRetryLimit ->
            Logger.debug('Unable to restore iptables after retry number: #{r}')
        end
    end
  end


  def subscriber_loop(_routingKey, _cType, payload, state) do
    proplist = :erlang.binary_to_term(payload)
    userData = :proplists.get_value(:user_data, proplist)
    r4IpsetsRuleset = :maps.get(:ruleset4_ipset, userData, false)
    r6IpsetsRuleset = :maps.get(:ruleset6_ipset, userData, false)
    r4IptablesRuleset = :maps.get(:ruleset4_iptables, userData, false)
    r6IptablesRuleset = :maps.get(:ruleset6_iptables, userData, false)
    ipsets = :maps.get(:ipsets, userData, false)
    handle_callback(ipsets, r4IpsetsRuleset, r6IpsetsRuleset, r4IptablesRuleset, r6IptablesRuleset)
    {:ack, state}
  end


  def handle_callback(ipsets, r4IpsetsRuleset, r6IpsetsRuleset, r4IptablesRuleset, r6IptablesRuleset) do
    case(ipsets) do
      [] ->
        :pass
      _ ->
        case(Application.get_env(:dog, :use_ipsets, true)) do
          true ->
            :ok = :dog_agent.create_ipsets(ipsets)
          false ->
            :pass
        end
    end
    case(r4IpsetsRuleset) do
      false ->
        :pass
      _ ->
        :ok = write_ipv4_ipsets_ruleset(r4IpsetsRuleset)
    end
    case(r6IpsetsRuleset) do
      false ->
        :pass
      _ ->
        :ok = write_ipv6_ipsets_ruleset(r6IpsetsRuleset)
    end
    case(r4IptablesRuleset) do
      false ->
        :pass
      _ ->
        Logger.debug('R4IptablesRuleset: #{r4IptablesRuleset}')
        :ok = write_ipv4_iptables_ruleset(r4IptablesRuleset)
    end
    case(r6IptablesRuleset) do
      false ->
        :pass
      _ ->
        Logger.debug('R6IptablesRuleset: #{r6IptablesRuleset}')
        :ok = write_ipv6_iptables_ruleset(r6IptablesRuleset)
    end
    case(Application.get_env(:dog, :use_ipsets, true)) do
      true ->
        case(r4IpsetsRuleset) do
          false ->
            Logger.debug('No v4 ipset ruleset to apply')
            :pass
          _ ->
            :ok = update_iptables4(r4IpsetsRuleset)
        end
        case(r6IpsetsRuleset) do
          false ->
            Logger.debug('No v6 ipset ruleset to apply')
            :pass
          _ ->
            :ok = update_iptables6(r6IpsetsRuleset)
        end
      false ->
        case(r4IptablesRuleset) do
          false ->
            Logger.debug('No v4 iptables ruleset to apply')
            :pass
          _ ->
            :ok = update_iptables4(r4IptablesRuleset)
        end
        case(r6IptablesRuleset) do
          false ->
            Logger.debug('No v6 iptables ruleset to apply')
            :pass
          _ ->
            :ok = update_iptables6(r6IptablesRuleset)
        end
    end
  end


  def remove_comments(ruleset) do
    noCommentRulesList = :lists.filter(fn x -> case(:re.run(x, '^#')) do
      :nomatch ->
        true
      _ ->
        false
    end end, split(ruleset, '\n', :all))
    noCommentRules = :lists.flatten(:lists.join('\n', noCommentRulesList))
    noCommentRules
  end


  def remove_docker(ruleset) do
    :lists.map(fn line0 ->
      line1 = :re.replace(line0, '^-A DOCKER(.*)', [], return: :list)
      line2 = :re.replace(line1, '^:DOCKER(.*)', [], return: :list)
      line3 = case(line2) do
        '-A FORWARD -j REJECT --reject-with icmp-port-unreachable' ->
          line2
        _ ->
          :re.replace(line2, '^-A FORWARD(.*)', [], return: :list)
      end
      line3
    end, ruleset)
  end


  defp remove_lxd(ruleset) do
    :lists.map(fn line0 ->
      line1 = :re.replace(line0, '^-A INPUT -i lxdbr0 (.*)', [], return: :list)
      line2 = :re.replace(line1, '^-A FORWARD -o lxdbr0 (.*)', [], return: :list)
      line3 = :re.replace(line2, '^-A FORWARD -i lxdbr0 (.*)', [], return: :list)
      line4 = :re.replace(line3, '^-A POSTROUTING -o lxdbr0 (.*)', [], return: :list)
      line4
    end, ruleset)
  end


  defp remove_empty_lists(list) do
    for(l <- list, l !== [], into: [], do: l)
  end


  def remove_quotes(line0) do
    line1 = :re.replace(line0, '"', [], [{:return, :list}, :global])
    line2 = :re.replace(line1, '\'', [], [{:return, :list}, :global])
    line2
  end


  @spec zero_counters(iolist()) :: iolist()


  defp zero_counters(ruleset) do
    :re.replace(ruleset, '(:.*) \\[.*\\]', '\\1 [0:0]', [{:return, :list}, :global])
  end


  @spec normalize_ruleset(iolist()) :: iolist()


  def normalize_ruleset(ruleset) do
    rulesetNoComments = remove_comments(ruleset)
    rulesetZeroed = zero_counters(rulesetNoComments)
    rulesetSplit = split(rulesetZeroed, '\n', :all)
    rulesetNoQuotes = for(line <- rulesetSplit, into: [], do: remove_quotes(line))
    rulesetTrimmed = for(line <- rulesetNoQuotes, into: [], do: trim(line, :trailing, ' '))
    rulesetNoDocker = remove_docker(rulesetTrimmed)
    rulesetNoLxd = remove_lxd(rulesetNoDocker)
    rulesetNoBlankLines = remove_empty_lists(rulesetNoLxd)
    rulesetNormalized = :lists.flatten(:lists.join('\n', rulesetNoBlankLines))
    rulesetNormalized
  end


  @spec create_hash(charlist()) :: any()


  def create_hash(ruleset) do
    rulesetTrimmed = normalize_ruleset(ruleset)
    encode(:crypto.hash(:sha256, rulesetTrimmed))
  end


  @spec rule_count(charlist()) :: number()


  def rule_count(ruleset) do
    rules = :lists.filter(fn x -> case(:re.run(x, '^-A ')) do
      :nomatch ->
        false
      _ ->
        true
    end end, :dog_string.split(ruleset, '\n', :all))
    length(rules)
  end


  defp encode(data) do
    for(<<n <- data>>, into: <<>>, do: <<hex(div(n, 16)), hex(rem(n, 16))>>)
  end


  defp hex(n) when n < 10 do
    n + ?0
  end

  defp hex(n) when n < 16 do
    n - 10 + ?a
  end


  defp trim(string, :trailing, ' ') do
    :re.replace(:re.replace(string, '\\s+$', [], [:global, {:return, :list}]), '^\\s+', [], [:global, {:return, :list}])
  end


  defp split(string, delimiter, :all) do
    split(string, delimiter)
  end


  defp split(string, delimiter) do
    :re.split(string, delimiter, return: :list)
  end

end
