# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-12-26 15:52:15


defmodule :dog_docker do
  require Logger

  @spec is_docker_instance() :: boolean()


  def is_docker_instance() do
    dockerSocketUrl = :maps.get(:docker_http, :maps.from_list(:application.get_all_env(:erldocker)), "http+unix://%2Fvar%2Frun%2Fdocker.sock")
    case(:hackney.get(dockerSocketUrl)) do
      {:ok, _, _, _} ->
        true
      {:error, _} ->
        false
    end
  end


  @spec any_docker_containers() :: boolean()


  def any_docker_containers() do
    case(is_docker_instance()) do
      true ->
        {:ok, containers} = :docker_container.containers()
        case(containers) do
          [] ->
            false
          _ ->
            true
        end
      false ->
        false
    end
  end


  @spec iptables() :: {iolist(), iolist()}


  def iptables() do
    defaultNetwork = default_network()
    containerNetworks = container_networks()
    d = fn template -> for_default_network(defaultNetwork, template) end
    c = fn template -> per_container(containerNetworks, defaultNetwork, template) end
    n = fn template -> per_network(containerNetworks, defaultNetwork, template) end
    p = fn string -> :io_lib.format('~s', [string]) end
    iptablesNat = [d.("*nat
    :PREROUTING ACCEPT [0:0]
    :INPUT ACCEPT [0:0]
    :OUTPUT ACCEPT [0:0]
    :POSTROUTING ACCEPT [0:0]
    :DOCKER - [0:0]
    -A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
    -A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER"), d.("-A POSTROUTING -s {{container_network}} ! -o {{bridge_interface}} -j MASQUERADE"), c.("-A POSTROUTING -s {{container_ip}}/32 -d {{container_ip}}/32 -p {{protocol}} -m {{protocol}} --dport {{private_port}} -j MASQUERADE"), d.("-A DOCKER -i {{bridge_interface}} -j RETURN"), c.("-A DOCKER -i {{bridge_interface}} -j RETURN"), c.("-A DOCKER ! -i {{bridge_interface}} -p {{protocol}} -m {{protocol}} --dport {{public_port}} -j DNAT --to-destination {{container_ip}}:{{private_port}}"), p.("COMMIT"), p.("")]
    iptablesFilter = [p.(":DOCKER - [0:0]
    :DOCKER-ISOLATION-STAGE-1 - [0:0]
    :DOCKER-ISOLATION-STAGE-2 - [0:0]
    :DOCKER-USER - [0:0]"), n.("-I FORWARD 1 -i {{bridge_interface}} -o {{bridge_interface}} -j ACCEPT
    -I FORWARD 1 -i {{bridge_interface}} ! -o {{bridge_interface}} -j ACCEPT
    -I FORWARD 1 -o {{bridge_interface}} -j DOCKER
    -I FORWARD 1 -o {{bridge_interface}} -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"), p.("-I FORWARD 1 -j DOCKER-ISOLATION-STAGE-1
    -I FORWARD 1 -j DOCKER-USER"), c.("-A DOCKER -d {{container_ip}}/32 ! -i {{bridge_interface}} -o {{bridge_interface}} -p tcp -m tcp --dport {{private_port}} -j ACCEPT"), d.("-A DOCKER-ISOLATION-STAGE-1 -i {{bridge_interface}} ! -o {{bridge_interface}} -j DOCKER-ISOLATION-STAGE-2"), n.("-A DOCKER-ISOLATION-STAGE-1 -i {{bridge_interface}} ! -o {{bridge_interface}} -j DOCKER-ISOLATION-STAGE-2"), p.("-A DOCKER-ISOLATION-STAGE-1 -j RETURN"), d.("-A DOCKER-ISOLATION-STAGE-2 -o {{bridge_interface}} -j DROP"), n.("-A DOCKER-ISOLATION-STAGE-2 -o {{bridge_interface}} -j DROP"), p.("-A DOCKER-ISOLATION-STAGE-2 -j RETURN"), p.("-A DOCKER-USER -j RETURN"), p.("COMMIT"), p.("")]
    iptablesNatString = :string.join(for(l <- iptablesNat, l !== [], into: [], do: l), '\n')
    iptablesFilterString = :string.join(for(l <- iptablesFilter, l !== [], into: [], do: l), '\n')
    {iptablesNatString, iptablesFilterString}
  end


  def default_network() do
    {:ok, defaultBridgeNetwork} = :docker_container.network("bridge")
    defaultBridgeNetworkMap = :jsn.new(defaultBridgeNetwork)
    defaultBridgeSubnet = :maps.get("Subnet", :maps.from_list(:lists.flatten(:maps.get("Config", :maps.from_list(:maps.get("IPAM", defaultBridgeNetworkMap))))))
    defaultBridgeName = :maps.get("com.docker.network.bridge.name", :maps.from_list(:maps.get("Options", defaultBridgeNetworkMap)))
    %{'container_network' => defaultBridgeSubnet, 'bridge_interface' => defaultBridgeName}
  end


  def container_networks() do
    {:ok, containers} = :docker_container.containers()
    containerNetworks = case(containers) do
      [] ->
        []
      _ ->
        :lists.map(fn container ->
          containerMap = :jsn.new(container)
          networkMode = :maps.get("NetworkMode", :maps.from_list(:maps.get("HostConfig", containerMap)))
          containerNetworks = :maps.get("Networks", :maps.from_list(:maps.get("NetworkSettings", containerMap)))
          nets = :lists.map(fn network ->
            networkMap = :jsn.new(network)
            nmap = :maps.from_list(hd(:maps.values(networkMap)))
            containerIp = :maps.get("IPAddress", nmap)
            containerNetmask = :maps.get("IPPrefixLen", nmap)
            networkId = :binary.bin_to_list(:maps.get("NetworkID", nmap))
            shortNetworkId = :binary.list_to_bin(:string.slice(networkId, 0, 12))
            bridgePrefix = "br-"
            bridgeInterface = <<bridgePrefix::binary, shortNetworkId::binary>>
            {:ok, parsedContainerIp} = :inet.parse_address(:erlang.binary_to_list(containerIp))
            m = :inet_utils.mask_address(parsedContainerIp, containerNetmask)
            containerNetwork = :erlang.binary_to_list(:inet_utils.inet_ntoa(m)) ++ '/' ++ :erlang.integer_to_list(containerNetmask)
            %{'bridge_interface' => bridgeInterface, 'container_ip' => containerIp, 'container_netmask' => containerNetmask, 'container_network' => containerNetwork}
          end, containerNetworks)
          containerPorts = :maps.get("Ports", containerMap)
          :lists.map(fn port ->
            portMap = :jsn.new(port)
            hostIP = :maps.get("IP", portMap, [])
            privatePort = :maps.get("PrivatePort", portMap)
            protocol = :maps.get("Type", portMap)
            publicPort = :maps.get("PublicPort", portMap, [])
            case(publicPort) do
              [] ->
                []
              _ ->
                %{'network_mode' => networkMode, 'host_ip' => hostIP, 'public_port' => publicPort, 'private_port' => privatePort, 'protocol' => protocol, 'nets' => nets}
            end
          end, containerPorts)
        end, containers)
    end
    :lists.reverse(:lists.flatten(containerNetworks))
  end


  def get_interfaces(containerNetworks, defaultNetwork) do
    bridgeInterfaces = :lists.map(fn container ->
      nets = :maps.get('nets', container)
      :lists.map(fn net -> {:maps.get('bridge_interface', net), net} end, nets)
    end, containerNetworks)
    defaultBridgeInterface = {:maps.get('bridge_interface', defaultNetwork), defaultNetwork}
    :maps.values(:maps.from_list(:lists.flatten([bridgeInterfaces, defaultBridgeInterface])))
  end


  def per_container(containerNetworks, defaultNetwork, template) do
    :string.join(:lists.map(fn container ->
      nets = :maps.get('nets', container)
      networkMode = :maps.get('network_mode', container)
      :lists.map(fn net ->
        net2 = case(networkMode) do
          "default" ->
            :maps.merge(:maps.merge(net, defaultNetwork), container)
          _ ->
            :maps.merge(:maps.merge(defaultNetwork, net), container)
        end
        :bbmustache.render(template, net2)
      end, nets)
    end, containerNetworks), '\n')
  end


  def per_network(containerNetworks, defaultNetwork, template) do
    interfaces = get_interfaces(containerNetworks, defaultNetwork)
    :string.join(:lists.map(fn net ->
      r = :erlang.binary_to_list(:bbmustache.render(template, net))
      r
    end, interfaces), '\n')
  end


  def for_default_network(defaultNetwork, template) do
    r = :erlang.binary_to_list(:bbmustache.render(template, defaultNetwork))
    r
  end

end
