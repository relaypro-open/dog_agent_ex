# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-12-26 15:52:16


defmodule :dog_ipset do
  require Logger
  require DogMacros
  alias DogMacros, as: M


  @spec create_ipsets(iolist()) :: :ok


  def create_ipsets(ipsetConf) do
    :ok = write_temp_file(ipsetConf)
    case(restore_ipset()) do
      :ok ->
        Logger.debug('Successfully restored ipset')
        :ok
      {:error, [{_restoreError, _restoreCode}, {:stderr, _cmdError}]} ->
        Logger.debug('Error restoring ipset')
    end
    :ok = persist_ipset()
    cleanup_ipset()
    :ok
  end


  @spec write_temp_file(iolist()) :: :ok | {:error, iolist()}


  defp write_temp_file(ipsetConf) do
    {:ok, tmpFile} = :file.open(M.erlconst_RUNDIR() ++ '/ipset.txt', [:write])
    result = :file.write(tmpFile, ipsetConf)
    :file.close(tmpFile)
    case(result) do
      :ok ->
        Logger.debug('wrote ipset.txt')
        :ok
      {:error, error} ->
        Logger.debug('error: #{error}')
        {:error, error}
    end
  end


  @spec restore_ipset() :: :ok | {:error, list()}


  defp restore_ipset() do
    restore_ipset(0)
  end


  @spec restore_ipset(integer()) :: :ok | {:error, list()}


  defp restore_ipset(errorCount) do
    ipsetRestoreRetryLimit = :application.get_env(:dog, :ipset_restore_retry_limit, 2)
    ipsetRestoreRetryWaitSeconds = :application.get_env(:dog, :ipset_restore_retry_wait_seconds, 2)
    ipsetRestoreWaitSeconds = :application.get_env(:dog, :ipset_restore_wait_seconds, 3)
    restoreCmd = 'cat ' ++ M.erlconst_RUNDIR() ++ '/ipset.txt | /home/dog/bin/ipset restore -exist'
    result = :dog_os.cmd(restoreCmd)
    :timer.sleep(ipsetRestoreWaitSeconds * 1000)
    case(result) do
      [] ->
        :ok
      restoreError ->
        nextErrorCount = errorCount + 1
        case(errorCount) do
          ^errorCount when errorCount <= ipsetRestoreRetryLimit ->
            :timer.sleep(ipsetRestoreRetryWaitSeconds * 1000)
            restore_ipset(nextErrorCount)
            :ok
          ^errorCount when errorCount > ipsetRestoreRetryLimit ->
            {:error, restoreError}
        end
    end
  end


  @spec persist_ipset() :: :ok | {:error, list()}


  defp persist_ipset() do
    persistCmd = '/home/dog/bin/ipset save | tee /etc/iptables/rules.ipset'
    :dog_os.cmd(persistCmd)
    :ok
  end


  @spec read_current_ipset() :: list() | {:error, list(), {:stderr, iolist()}}


  def read_current_ipset() do
    readCmd = '/home/dog/bin/ipset save'
    case(:dog_os.cmd(readCmd)) do
      [] ->
        []
      readCmdResult ->
        l = :io_lib.format('~s', [:lists.flatten(readCmdResult)])
        :lists.flatten(l)
    end
  end


  @spec create_hash(charlist()) :: any()


  def create_hash(ipset) do
    :base16.encode(:crypto.hash(:sha256, ipset))
  end


  @spec read_hash() :: binary()


  def read_hash() do
    normalizedIpset = normalize_ipset(read_current_ipset())
    ipsetHash = create_hash(normalizedIpset)
    ipsetHash
  end


  @spec match_only_add(iolist()) :: boolean()


  defp match_only_add(line) do
    case(:re.run(line, '^add (.*)')) do
      {:match, _} ->
        true
      :nomatch ->
        false
    end
  end


  @spec normalize_ipset(iolist()) :: iolist()


  def normalize_ipset(ipset) do
    ipsetSplit = :dog_string.split(ipset, '\n', :all)
    ipsetSorted = :lists.sort(ipsetSplit)
    ipsetAddOnly = :lists.filter(fn x -> match_only_add(x) end, ipsetSorted)
    ipsetNotNew = for(x <- ipsetAddOnly, into: [], do: :lists.flatten(:dog_string.replace(x, 'n ', ' ', :all)))
    ipsetNot32 = for(x <- ipsetNotNew, into: [], do: :lists.flatten(:dog_string.replace(x, '/32', [], :all)))
    ipsetNot128 = for(x <- ipsetNot32, into: [], do: :lists.flatten(:dog_string.replace(x, '/128', [], :all)))
    ipsetTrimmed = for(line <- ipsetNot128, into: [], do: :dog_string.trim(line, :trailing, ' '))
    ipsetNormalized = :lists.flatten(:lists.join('\n', ipsetTrimmed))
    ipsetNormalized
  end


  @spec cleanup_ipset() :: :ok


  def cleanup_ipset() do
    _one = :dog_os.cmd('grep create /etc/dog_ex/ipset.txt | awk \'{print $2}\' | sort | uniq > /etc/dog_ex/1.tmp')
    _two = :dog_os.cmd('/home/dog/bin/ipset list -name | sort | uniq > /etc/dog_ex/2.tmp')
    cmd = 'for name in `comm -1 -3 /etc/dog_ex/1.tmp /etc/dog_ex/2.tmp`;do echo destroy $name;done > /etc/dog_ex/ipset_cleanup.txt; cat /etc/dog_ex/ipset_cleanup.txt | /home/dog/bin/ipset restore; rm /etc/dog_ex/1.tmp /etc/dog_ex/2.tmp'
    case(:dog_os.cmd(cmd)) do
      [] ->
        :ok
      cmdError ->
        {:error, cmdError}
    end
  end

end
