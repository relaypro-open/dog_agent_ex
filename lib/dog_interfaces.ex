# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-12-26 15:52:16


defmodule :dog_interfaces do
  require Logger

  defmacrop erlconst_IPsExchange() do
    quote do
      "ips"
    end
  end


  defmacrop erlconst_EC2_METADATA_BASE_URL() do
    quote do
      'http://169.254.169.254'
    end
  end


  defmacrop erlconst_IBM_METADATA_BASE_URL() do
    quote do
      'https://api.service.softlayer.com'
    end
  end


  @spec get_provider() :: binary()


  def get_provider() do
    case(is_ec2_instance()) do
      true ->
        is_ec2_private_instance()
        "ec2"
      false ->
        case(is_softlayer_instance()) do
          true ->
            "softlayer"
          false ->
            "unknown"
        end
    end
  end


  @spec is_softlayer_instance() :: boolean()


  def is_softlayer_instance() do
    url = erlconst_IBM_METADATA_BASE_URL() ++ '/rest/v3/SoftLayer_Resource_Metadata/getPrimaryIpAddress'
    method = :get
    headers = []
    payload = <<>>
    options = [connect_timeout: 1000]
    isSoftlayerInstance = case(:application.get_env(:dog, :is_softlayer_instance)) do
      {:ok, boolean} ->
        boolean
      _ ->
        case(:hackney.request(method, url, headers, payload, options)) do
          {:error, _error} ->
            false
          {:ok, statusCode, _respHeaders, _clientRef} ->
            case(statusCode) do
              200 ->
                true
              _ ->
                false
            end
        end
    end
    :application.set_env(:dog, :is_softlayer_instance, isSoftlayerInstance)
    isSoftlayerInstance
  end


  @spec is_ec2_instance() :: boolean()


  def is_ec2_instance() do
    isEc2Istance = case(:application.get_env(:dog, :is_ec2_instance)) do
      {:ok, boolean} ->
        boolean
      _ ->
        url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/'
        method = :get
        headers = [{"Content-Type", "text/plain"}]
        payload = <<>>
        options = [connect_timeout: 1000]
        case(:hackney.request(method, url, headers, payload, options)) do
          {:error, _error} ->
            false
          {:ok, statusCode, _respHeaders, _clientRef} ->
            case(statusCode) do
              200 ->
                true
              _ ->
                false
            end
        end
    end
    :application.set_env(:dog, :is_ec2_instance, isEc2Istance)
    isEc2Istance
  end


  @spec is_ec2_private_instance() :: boolean()


  def is_ec2_private_instance() do
    case(:application.get_env(:dog, :is_ec2_private_instance)) do
      {:ok, boolean} ->
        boolean
      _ ->
        case(ec2_public_ipv4()) do
          {:error, :notfound} ->
            :application.set_env(:dog, :is_ec2_private_instance, true)
            true
          {:error, _} ->
            false
          _addresses ->
            :application.set_env(:dog, :is_ec2_private_instance, false)
            false
        end
    end
  end


  @spec is_docker_instance() :: boolean()


  def is_docker_instance() do
    :dog_docker.is_docker_instance()
  end


  @spec ec2_info() :: {char_list(), char_list(), char_list(), char_list(), char_list(), map(), char_list(), char_list()}


  def ec2_info() do
    case(is_ec2_instance()) do
      true ->
        {ec2_region(), ec2_instance_id(), ec2_availability_zone(), ec2_security_group_ids(), ec2_owner_id(), ec2_instance_tags(), ec2_vpc_id(), ec2_subnet_id()}
      false ->
        {"", "", "", "", "", %{}, "", ""}
    end
  end


  @spec ec2_public_ipv4() :: list() | {:error, atom()}


  def ec2_public_ipv4() do
    case(:application.get_env(:dog, :is_ec2_private_instance)) do
      {:ok, true} ->
        {:error, :notfound}
      _ ->
        case(ec2_macs()) do
          {:error, reason} ->
            {:error, reason}
          macs ->
            results = :lists.flatten(for(mac <- macs, into: [], do: ec2_public_ipv4(mac)))
            anyNotFound = :lists.any(fn
              {:error, :notfound} ->
                true
              _ ->
                false
            end, results)
            anyFailures = :lists.any(fn
              {:error, reason} when reason !== :notfound ->
                true
              _ ->
                false
            end, results)
            addresses = :lists.filter(fn
              x when is_binary(x) ->
                true
              _ ->
                false
            end, results)
            case(:if) do
              :if when length(addresses) > 0 ->
                :lists.flatten(addresses)
              :if when anyFailures ->
                {:error, :request_failed}
              :if when anyNotFound ->
                {:error, :notfound}
              :if when true ->
                {:error, :unknown}
            end
        end
    end
  end


  @spec ec2_region() :: char_list()


  def ec2_region() do
    case(ec2_availability_zone()) do
      "" ->
        ""
      aZ ->
        :string.slice(aZ, 0, :string.length(aZ) - 1)
    end
  end


  @spec ec2_availability_zone() :: char_list()


  def ec2_availability_zone() do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/placement/availability-zone'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        ""
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, instanceId} = :hackney.body(clientRef)
            instanceId
          _ ->
            ""
        end
    end
  end


  @spec ec2_instance_id() :: char_list()


  def ec2_instance_id() do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/instance-id'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        ""
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, instanceId} = :hackney.body(clientRef)
            instanceId
          _ ->
            ""
        end
    end
  end


  @spec ec2_security_group_ids() :: list() | []


  def ec2_security_group_ids() do
    case(ec2_macs()) do
      {:error, _} ->
        []
      macs ->
        results = :lists.map(fn mac -> ec2_security_group_ids(mac) end, macs)
        case(:lists.any(fn result -> result == {:error, :notfound} end, results)) do
          true ->
            []
          false ->
            :lists.flatten(results)
        end
    end
  end


  @spec ec2_security_group_ids(char_list()) :: list() | []


  defp ec2_security_group_ids(mac) do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/network/interfaces/macs/' ++ mac ++ '/security-group-ids'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        []
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            securityGroups = :re.split(body, '\n', return: :list)
            securityGroupsStrings = for(sg <- securityGroups, into: [], do: :erlang.list_to_binary(sg))
            securityGroupsStrings
          _ ->
            []
        end
    end
  end


  @spec ec2_owner_id() :: char_list()


  def ec2_owner_id() do
    case(ec2_macs()) do
      {:error, _} ->
        ""
      macs ->
        results = :lists.map(fn mac -> ec2_owner_id(mac) end, macs)
        case(:lists.any(fn result -> result == {:error, :notfound} end, results)) do
          true ->
            ""
          false ->
            hd(results)
        end
    end
  end


  @spec ec2_owner_id(char_list()) :: char_list()


  defp ec2_owner_id(mac) do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/network/interfaces/macs/' ++ mac ++ '/owner-id'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        {:error, :notfound}
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            owners = :re.split(body, '\n', return: :list)
            ownersStrings = for(sg <- owners, into: [], do: :erlang.list_to_binary(sg))
            hd(ownersStrings)
          _ ->
            {:error, :notfound}
        end
    end
  end


  @spec ec2_subnet_id() :: char_list()


  def ec2_subnet_id() do
    case(ec2_macs()) do
      {:error, _} ->
        ""
      macs ->
        results = :lists.map(fn mac -> ec2_subnet_id(mac) end, macs)
        case(:lists.any(fn result -> result == {:error, :notfound} end, results)) do
          true ->
            ""
          false ->
            hd(results)
        end
    end
  end


  @spec ec2_subnet_id(char_list()) :: char_list()


  defp ec2_subnet_id(mac) do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/network/interfaces/macs/' ++ mac ++ '/subnet-id'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        {:error, :notfound}
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            owners = :re.split(body, '\n', return: :list)
            ownersStrings = for(sg <- owners, into: [], do: :erlang.list_to_binary(sg))
            hd(ownersStrings)
          _ ->
            {:error, :notfound}
        end
    end
  end


  @spec ec2_vpc_id() :: char_list()


  def ec2_vpc_id() do
    case(ec2_macs()) do
      {:error, _} ->
        ""
      macs ->
        results = :lists.map(fn mac -> ec2_vpc_id(mac) end, macs)
        case(:lists.any(fn result -> result == {:error, :notfound} end, results)) do
          true ->
            ""
          false ->
            hd(results)
        end
    end
  end


  @spec ec2_vpc_id(char_list()) :: char_list()


  defp ec2_vpc_id(mac) do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/network/interfaces/macs/' ++ mac ++ '/vpc-id'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        {:error, :notfound}
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            owners = :re.split(body, '\n', return: :list)
            ownersStrings = for(sg <- owners, into: [], do: :erlang.list_to_binary(sg))
            hd(ownersStrings)
          _ ->
            {:error, :notfound}
        end
    end
  end


  @spec ec2_public_ipv4(char_list()) :: list() | {:error, atom() | integer()}


  defp ec2_public_ipv4(mac) do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/network/interfaces/macs/' ++ mac ++ '/public-ipv4s'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, error} ->
        {:error, :failed}
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            :lists.flatten(:re.split(body, '\n', return: :binary))
          404 ->
            {:error, :notfound}
          _ ->
            {:error, statusCode}
        end
    end
  end


  @spec ec2_macs() :: list() | {:error, atom()}


  def ec2_macs() do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/network/interfaces/macs/'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        {:error, :notfound}
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            macs = :re.split(body, '\n', return: :list)
            macStrings0 = for(mac <- macs, into: [], do: mac)
            macStrings1 = for(mac <- macStrings0, into: [], do: :lists.flatten(:re.split(mac, '/', return: :list)))
            macStrings1
          _ ->
            {:error, :notfound}
        end
    end
  end


  @spec get_interfaces_with_ips() :: {:ok, list({_, _})} when _: any()


  def get_interfaces_with_ips() do
    {:ok, interfaces} = :inet.getifaddrs()
    iP_Interfaces = for({name, flags} <- interfaces, :lists.any(fn flag -> flag == :addr end, :proplists.get_keys(flags)), into: [], do: {name, flags})
    {:ok, iP_Interfaces}
  end


  @spec get_interfaces(binary(), any()) :: {:ok, iolist()}


  def get_interfaces(provider, oldInterfaces) do
    case(provider) do
      "ec2" ->
        {:ok, localInterfaces} = get_local_interfaces()
        case(is_ec2_private_instance()) do
          true ->
            {:ok, localInterfaces}
          false ->
            case(ec2_public_ipv4()) do
              {:error, _} ->
                oldPublicIpv4 = :proplists.get_value("ec2_public_ipv4", oldInterfaces, [])
                both = :lists.append(localInterfaces, [{"ec2_public_ipv4", oldPublicIpv4}])
                {:ok, both}
              ec2PublicIpv4 ->
                both = :lists.append(localInterfaces, [{"ec2_public_ipv4", ec2PublicIpv4}])
                {:ok, both}
            end
        end
      _ ->
        get_local_interfaces()
    end
  end


  @spec get_local_interfaces() :: {:ok, list()}


  def get_local_interfaces() do
    {:ok, iP_Interfaces} = get_interfaces_with_ips()
    interfaces = :lists.map(fn {x, y} -> {:erlang.list_to_binary(x), for(a <- y, :proplists.get_keys([a]) == [:addr], into: [], do: a)} end, iP_Interfaces)
    interfaces2 = for({x, y} <- interfaces, into: [], do: {x, for(a <- :proplists.get_all_values(:addr, y), into: [], do: :erlang.list_to_binary(:inet_parse.ntoa(a)))})
    {:ok, interfaces2}
  end


  @spec get_fqdn() :: {:ok, binary()}


  def get_fqdn() do
    {:ok, hostname} = :inet.gethostname()
    {:ok, {:hostent, fullHostname, _, :inet, _, _}} = :inet.gethostbyname(hostname)
    var_fqdn = case(:string.left(fullHostname, 9)) do
      'localhost' ->
        case(hostname) do
          'localhost' ->
            :quickrand.seed()
            :uuid.get_v4_urandom()
          _ ->
            hostname
        end
      _ ->
        fullHostname
    end
    {:ok, :binary.list_to_bin(var_fqdn)}
  end


  @spec fqdn() :: binary()


  def fqdn() do
    {:ok, var_fqdn} = get_fqdn()
    var_fqdn
  end


  @spec get_group_key() :: {:ok, binary()}


  def get_group_key() do
    {:ok, group} = :application.get_env(:dog, :group)
    {:ok, :erlang.list_to_binary(group)}
  end


  @spec get_environment_key() :: {:ok, binary()}


  def get_environment_key() do
    {:ok, environment} = :application.get_env(:dog, :environment)
    {:ok, :erlang.list_to_binary(environment)}
  end


  @spec get_location_key() :: {:ok, binary()}


  def get_location_key() do
    {:ok, location} = :application.get_env(:dog, :location)
    {:ok, :erlang.list_to_binary(location)}
  end


  @spec get_host_key() :: {:ok, binary()}


  def get_host_key() do
    {:ok, hostKey} = :application.get_env(:dog, :hostkey)
    {:ok, :erlang.list_to_binary(hostKey)}
  end


  @spec publish_to_queue(map()) :: any()


  def publish_to_queue(config) do
    userData = %{config: config}
    count = 1
    brokerRoutingKey = "ips"
    pid = :erlang.self()
    message = :erlang.term_to_binary(count: count, local_time: :calendar.local_time(), pid: pid, user_data: userData)
    response = :turtle.publish(:ips_publisher, erlconst_IPsExchange(), brokerRoutingKey, "text/json", message, %{delivery_mode: :persistent})
    response
  end


  @spec ip_to_queue() :: any()


  def ip_to_queue() do
    group = 'test'
    hostname = 'test-tt-aws01.test.test'
    environment = 'qa'
    location = 'us-east-1'
    hostKey = 'test-tt-aws01'
    interfaces = [{'lo', [addr: {127, 0, 0, 1}]}, {'eth0', [addr: {10, 1, 1, 51}]}]
    updateType = :update
    config = %{"name" => hostname, "interfaces" => interfaces, "group" => group, "location" => location, "environment" => environment, "hostkey" => hostKey, "updatetype" => updateType}
    publish_to_queue(config)
  end


  @spec ec2_instance_tag(char_list()) :: list() | []


  def ec2_instance_tag(tag) do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/tags/instance/' ++ tag
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _} ->
        []
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            {tag, body}
        end
    end
  end


  @spec ec2_instance_tags() :: map()


  def ec2_instance_tags() do
    url = erlconst_EC2_METADATA_BASE_URL() ++ '/latest/meta-data/tags/instance/'
    method = :get
    headers = [{"Content-Type", "text/plain"}]
    payload = <<>>
    options = [connect_timeout: 1000]
    case(:hackney.request(method, url, headers, payload, options)) do
      {:error, _error} ->
        %{}
      {:ok, statusCode, _respHeaders, clientRef} ->
        case(statusCode) do
          200 ->
            {:ok, body} = :hackney.body(clientRef)
            tagNames = :re.split(body, '\n', [{:return, :list}, :trim])
            tagNamesStrings = for(tn <- tagNames, into: [], do: :erlang.list_to_binary(tn))
            results = :lists.map(fn tag -> ec2_instance_tag(tag) end, tagNamesStrings)
            :maps.from_list(results)
          _ ->
            %{}
        end
    end
  end


  defp exec(command) do
    result = :exec.run(command, [:sync, :stdout, :stderr])
    case(result) do
      {:ok, [stdout: stdOut]} ->
        :string.trim(stdOut)
      _ ->
        []
    end
  end


  @spec os_info() :: tuple()


  def os_info() do
    oS_Distribution = exec('lsb_release -s -i')
    oS_Version = exec('lsb_release -s -r')
    {oS_Distribution, oS_Version}
  end

end
