# Generated by erl2ex (http://github.com/dazuma/erl2ex)
# From Erlang source: (Unknown source file)
# At: 2022-12-26 15:52:14


defmodule :dog_common do

  require Logger


  def to_list(item) when is_atom(item) do
    :erlang.atom_to_list(item)
  end

  def to_list(item) when is_list(item) do
    item
  end

  def to_list(item) when is_tuple(item) do
    :erlang.tuple_to_list(item)
  end

  def to_list(item) when is_map(item) do
    :maps.to_list(item)
  end

  def to_list(item) when is_binary(item) do
    :erlang.binary_to_list(item)
  end

  def to_list(item) when is_integer(item) do
    :erlang.integer_to_list(item)
  end

  def to_list(item) when is_float(item) do
    :erlang.float_to_list(item)
  end




  def re_filter(list, re) do
    :lists.filter(fn string -> case(:re.run(string, re)) do
      {:match, _} ->
        true
      :nomatch ->
        false
    end end, list)
  end


  def merge_maps_of_lists(listOfMapsOfLists) do
    merge_maps_of_lists(listOfMapsOfLists, %{})
  end


  defp merge_maps_of_lists([], acc) do
    acc
  end

  defp merge_maps_of_lists(listOfMapsOfLists, acc) do
    map = hd(listOfMapsOfLists)
    rest = tl(listOfMapsOfLists)
    keys = :maps.keys(map)
    newAcc = :lists.map(fn key ->
      existingList = :maps.get(key, acc, [])
      newList = :maps.get(key, map)
      mergedList = :sets.to_list(:sets.from_list(:lists.merge(existingList, newList)))
      {key, mergedList}
    end, keys)
    merge_maps_of_lists(rest, :maps.from_list(newAcc))
  end


  def lmm(listOfMaps, key) do
    list_of_maps_to_map(listOfMaps, key)
  end


  def list_of_maps_to_map(listOfMaps, key) do
    list_of_maps_to_map(listOfMaps, key, %{})
  end


  defp list_of_maps_to_map([], _key, mapAcc) do
    mapAcc
  end

  defp list_of_maps_to_map(listOfMaps, key, mapAcc) do
    keyValue = :maps.get(key, hd(listOfMaps))
    newMap = :maps.remove(key, hd(listOfMaps))
    mapAcc1 = :maps.put(keyValue, newMap, mapAcc)
    list_of_maps_to_map(tl(listOfMaps), key, mapAcc1)
  end


  def rekey_map_of_maps(mapOfMaps, newKey, oldKeysNewKey) do
    rkmm(mapOfMaps, newKey, oldKeysNewKey)
  end


  def rkmm(mapOfMaps, newKey, oldKeysNewKey) do
    iterator = :maps.iterator(mapOfMaps)
    next = :maps.next(iterator)
    rekey_map_of_maps(next, newKey, oldKeysNewKey, %{})
  end


  defp rekey_map_of_maps(:none, _newKey, _oldKeysNewKey, mapAcc) do
    mapAcc
  end

  defp rekey_map_of_maps(iterator, newKey, oldKeysNewKey, mapAcc) do
    {oldKey, oldValue, thisIterator} = iterator
    Logger.debug('Iterator: #{iterator}')
    newKeyValue = :maps.get(newKey, oldValue)
    newMap0 = :maps.remove(newKey, oldValue)
    newMap1 = :maps.put(oldKeysNewKey, oldKey, newMap0)
    mapAcc1 = :maps.put(newKeyValue, newMap1, mapAcc)
    newIterator = :maps.next(thisIterator)
    rekey_map_of_maps(newIterator, newKey, oldKeysNewKey, mapAcc1)
  end


  def merge_lists_in_tuples(list) do
    map = :lists.foldl(&fun_merge_lists_in_tuples/2, :maps.new(), list)
    :lists.map(fn {k, v} ->
      uniqueV = :lists.usort(:lists.flatten(v))
      {k, uniqueV}
    end, :maps.to_list(map))
  end


  defp fun_merge_lists_in_tuples(h, a) do
    k = :erlang.element(1, h)
    case(:maps.is_key(k, a)) do
      true ->
        v = :maps.get(k, a)
        :maps.put(k, [:erlang.element(2, h) | v], a)
      false ->
        :maps.put(k, :erlang.element(2, h), a)
    end
  end


  def inverse_map_of_lists(map) do
    mapList = :maps.to_list(map)
    tuplelist = :lists.map(fn {key, values} -> :lists.map(fn value -> {value, key} end, values) end, mapList)
    :lists.flatten(tuplelist)
  end


  def tuple_pairs_to_map_of_lists(tupleList) do
    tuple_pairs_to_map_of_lists(tupleList, %{})
  end


  defp tuple_pairs_to_map_of_lists([], accum) do
    accum
  end

  defp tuple_pairs_to_map_of_lists(tupleList, accum) do
    [head | tail] = tupleList
    {key, value} = head
    accum1 = maps_append(key, value, accum)
    tuple_pairs_to_map_of_lists(tail, accum1)
  end




  defp maps_append(key, value, map) do
    map1 = case(:maps.find(key, map)) do
      :error ->
        :maps.put(key, [value], map)
      {:ok, values} ->
        :maps.put(key, :lists.append(values, [value]), map)
    end
    map1
  end




  def binary_join([], _sep) do
    <<>>
  end

  def binary_join([part], _sep) do
    part
  end

  def binary_join(list, sep) do
    :lists.foldr(fn a, b -> case(:if) do
      :if when bit_size(b) > 0 ->
        <<a::binary, sep::binary, b::binary>>
      :if when true ->
        a
    end end, <<>>, list)
  end

end
